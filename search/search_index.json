{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DataStructureViz DSViz is a simple and intuitive Python interface to multiple packages in order to help visualise different data structres while codng them. This package is developed mainly for students or developers who are in the process of learning data structures. This packages acts as an interface to Tkinter a Python UI library and GraphViz which facillitates rendering of graphs described in the DOT language. This package can be used to visualise any implementations of the following: Array Lists Linked Lists Singly Linked Lists Doubly Linked Lists Circular Linked Lists Trees Graphs Directed Graphs Undirected Graphs Links GitHub: https://github.com/IshMehta/DSViz PyPI: https://pypi.org/project/DSViz/ Documentation: https://ishmehta.github.io/DSViz/","title":"Home"},{"location":"#datastructureviz","text":"DSViz is a simple and intuitive Python interface to multiple packages in order to help visualise different data structres while codng them. This package is developed mainly for students or developers who are in the process of learning data structures. This packages acts as an interface to Tkinter a Python UI library and GraphViz which facillitates rendering of graphs described in the DOT language. This package can be used to visualise any implementations of the following: Array Lists Linked Lists Singly Linked Lists Doubly Linked Lists Circular Linked Lists Trees Graphs Directed Graphs Undirected Graphs","title":"DataStructureViz"},{"location":"#links","text":"GitHub: https://github.com/IshMehta/DSViz PyPI: https://pypi.org/project/DSViz/ Documentation: https://ishmehta.github.io/DSViz/","title":"Links"},{"location":"BSTExample/","text":"Binary Search Tree Example The following is an example on a BST class which uses the TreeV class form the DSViz package to visualise the tree that will be created. from DSViz import BinaryTreeV class BST : class Node : def __init__ ( self , value ): self . value = value self . right = None self . left = None def __init__ ( self ): self . root = None self . viz = BinaryTreeV () def postorderVisualiser ( self , curr ): if curr is None : return else : if curr . left is None and curr . right is None : self . viz . add ( curr . value ) else : if curr . left is None : self . viz . add ( curr . value , right = curr . right . value ) elif curr . right is None : self . viz . add ( curr . value , left = curr . left . value ) else : self . viz . add ( curr . value , curr . left . value , curr . right . value ) self . postorderVisualiser ( curr . left ) self . postorderVisualiser ( curr . right ) def renderTree ( self ): self . viz . show def add ( self , value ): self . root = self . addHelper ( self . root , value ) def addHelper ( self , curr , value ): if curr is None : return self . Node ( value ) elif value < curr . value : curr . left = self . addHelper ( curr . left , value ) elif value > curr . value : curr . right = self . addHelper ( curr . right , value ) return curr One can make simple changes to a tree traversal. in this example we have used the postorder traversal as seen in the postorderVisualiser() method. Using this is quite simple. test = BST () test . add ( 100 ) test . add ( 50 ) test . add ( 25 ) test . add ( 27 ) test . add ( 51 ) test . add ( 55 ) test . add ( 155 ) test . postorderVisualiser ( test . root ) test . renderTree () This results in the following render.","title":"Binary Search Tree Example"},{"location":"BSTExample/#binary-search-tree-example","text":"The following is an example on a BST class which uses the TreeV class form the DSViz package to visualise the tree that will be created. from DSViz import BinaryTreeV class BST : class Node : def __init__ ( self , value ): self . value = value self . right = None self . left = None def __init__ ( self ): self . root = None self . viz = BinaryTreeV () def postorderVisualiser ( self , curr ): if curr is None : return else : if curr . left is None and curr . right is None : self . viz . add ( curr . value ) else : if curr . left is None : self . viz . add ( curr . value , right = curr . right . value ) elif curr . right is None : self . viz . add ( curr . value , left = curr . left . value ) else : self . viz . add ( curr . value , curr . left . value , curr . right . value ) self . postorderVisualiser ( curr . left ) self . postorderVisualiser ( curr . right ) def renderTree ( self ): self . viz . show def add ( self , value ): self . root = self . addHelper ( self . root , value ) def addHelper ( self , curr , value ): if curr is None : return self . Node ( value ) elif value < curr . value : curr . left = self . addHelper ( curr . left , value ) elif value > curr . value : curr . right = self . addHelper ( curr . right , value ) return curr One can make simple changes to a tree traversal. in this example we have used the postorder traversal as seen in the postorderVisualiser() method. Using this is quite simple. test = BST () test . add ( 100 ) test . add ( 50 ) test . add ( 25 ) test . add ( 27 ) test . add ( 51 ) test . add ( 55 ) test . add ( 155 ) test . postorderVisualiser ( test . root ) test . renderTree () This results in the following render.","title":"Binary Search Tree Example"},{"location":"array/","text":"ArrayListV <object> = ArrayListV() : Create object of ArrayListV class <object>.addNode(..item..) will add node to the array list beginning from index 0 upto n. Note You can only add one item at a time. We suggest you iterate over the Array List and call the .addNode() method on every item. <object>.show : Once every node has been added, use this property to render the array list.","title":"ArrayListV"},{"location":"array/#arraylistv","text":"<object> = ArrayListV() : Create object of ArrayListV class <object>.addNode(..item..) will add node to the array list beginning from index 0 upto n. Note You can only add one item at a time. We suggest you iterate over the Array List and call the .addNode() method on every item. <object>.show : Once every node has been added, use this property to render the array list.","title":"ArrayListV"},{"location":"binaryTree/","text":"BinaryTreeV <object> = BinaryTreeV() : Creates an object for this class There are 4 variations of the add method to add nodes to the tree: <object>.add(..parent..) : creates a single node with value = parent with children set to None/null <object>.add(..parent.., left = ..child..) : creates a parent node with a single left child <object>.add(..parent.., right = ..child..) : creates a parent node with a single right child <object>.add(..parent.., left = child, right = ..child..) : creates a parent node with a single left child and single right child Warning Two nodes with the same value cannot be created as each node is recognised by its value. While this may be a problem, it makes editing the tree relatively easier as one can add a node just by referenceing the parent nodes value. <object>.show : Once every node has been added, use this property to render the tree.","title":"BinaryTreeV"},{"location":"binaryTree/#binarytreev","text":"<object> = BinaryTreeV() : Creates an object for this class There are 4 variations of the add method to add nodes to the tree: <object>.add(..parent..) : creates a single node with value = parent with children set to None/null <object>.add(..parent.., left = ..child..) : creates a parent node with a single left child <object>.add(..parent.., right = ..child..) : creates a parent node with a single right child <object>.add(..parent.., left = child, right = ..child..) : creates a parent node with a single left child and single right child Warning Two nodes with the same value cannot be created as each node is recognised by its value. While this may be a problem, it makes editing the tree relatively easier as one can add a node just by referenceing the parent nodes value. <object>.show : Once every node has been added, use this property to render the tree.","title":"BinaryTreeV"},{"location":"directed_graph/","text":"Directed Graph Example from DSViz import GraphV class directedGraph : def __init__ ( self , adjlist , directed = False ): self . adjlist = adjlist self . viz = GraphV ( Directed = directed ) def show ( self ): for node in self . adjlist : for element in self . adjlist [ node ]: self . viz . add ( node , element ) self . viz . show One can then utilise this 'show' method created. adjlist3 = { 1 : [ 6 , 4 ], 2 : [ 9 , 7 , 5 ], 3 : [ 5 , 8 ], 4 : [ 9 ], 5 : [ 13 ], 6 : [ 10 , 9 ], 7 : [ 11 , 12 , 13 ], 8 : [ 14 ], 9 : [ 15 ], 10 : [], 11 : [ 15 ], 12 : [], 13 : [], 14 :[], 15 :[] } test = directedGraph ( adjlist3 , directed = True ) test . show () A similar approach can be followed to visualise any form of graph regardless of its implementation specifics.","title":"Directed Graph"},{"location":"directed_graph/#directed-graph-example","text":"from DSViz import GraphV class directedGraph : def __init__ ( self , adjlist , directed = False ): self . adjlist = adjlist self . viz = GraphV ( Directed = directed ) def show ( self ): for node in self . adjlist : for element in self . adjlist [ node ]: self . viz . add ( node , element ) self . viz . show One can then utilise this 'show' method created. adjlist3 = { 1 : [ 6 , 4 ], 2 : [ 9 , 7 , 5 ], 3 : [ 5 , 8 ], 4 : [ 9 ], 5 : [ 13 ], 6 : [ 10 , 9 ], 7 : [ 11 , 12 , 13 ], 8 : [ 14 ], 9 : [ 15 ], 10 : [], 11 : [ 15 ], 12 : [], 13 : [], 14 :[], 15 :[] } test = directedGraph ( adjlist3 , directed = True ) test . show () A similar approach can be followed to visualise any form of graph regardless of its implementation specifics.","title":"Directed Graph Example"},{"location":"graph/","text":"GraphV <object> = GraphV(Directed = False) : Creates an object of this class which will create an undirected graph Info Directed is set to False by default to create an undirected graph. To create a directed graph set Directed = True while object creation. <object>.add(..parent.. , ..child..) : creates 2 nodes parent and child while also creating an edge between the two. If Directed = True then the edge created will point from parent to child. Warning .add() method only accpets one parent and one child at a time For important use-cases check the examples section. Important To visualise a tree that is not a Binary Tree one can use the directed graph approach.","title":"GraphV"},{"location":"graph/#graphv","text":"<object> = GraphV(Directed = False) : Creates an object of this class which will create an undirected graph Info Directed is set to False by default to create an undirected graph. To create a directed graph set Directed = True while object creation. <object>.add(..parent.. , ..child..) : creates 2 nodes parent and child while also creating an edge between the two. If Directed = True then the edge created will point from parent to child. Warning .add() method only accpets one parent and one child at a time For important use-cases check the examples section. Important To visualise a tree that is not a Binary Tree one can use the directed graph approach.","title":"GraphV"},{"location":"guide/","text":"Getting Started DSViz is a simple and intuitive Python interface to multiple packages in order to help visualise different data structres while codng them. This package is developed mainly for students or developers who are in the process of learning data structures. How to use it ? Simple ! Step 1. Iterate over your Data Structure using the appropriate class Step 2. Call the .add() method on each node Step 3. Once you have added every node, use the .show property Step 4. Keep Coding ;) Here are a few examples... Array List Goal: Array List which stores even numbers from 2-100 from DSViz import ArrayListV test = ArrayListV () for i in range ( 1 , 51 ): test . addNode ( i * 2 ) test . show Linked List Goal: Circular Doubly Linked List which stores alphabets from a-z addNode(node) : adds nodes to the back of a linked list We suggest you start at the head of the linked list and iterate to the end and call the add method on each node. The below example gives an idea on how the add method works and how the data structure is visualised. LinkedListV object upon creation has default CLL = False and DLL = False. These can be toggled upon object creation to change the how the pointers in the visualisation. from DSViz import LinkedListV test = LinkedListV ( CLL = True , DLL = True ) for i in range ( 97 , 123 ): test . addNode ( chr ( i )) test . show Binary Tree Goal: Visualise a tree from DSViz import BinaryTreeV test = BinaryTreeV () test . add ( \"a\" , \"b\" , \"c\" ) test . add ( \"b\" , left = \"d\" ) test . add ( \"d\" , right = \"e\" ) test . show () Graph Goal: Visualise an undirected graph add(node1, node2) : creates an edge between two nodes, if the node exists, it creates an edge between the two, if node does not exist, it creates the node and the edge. We suggest you to use the add method while iterating over your graph using BFS or DFS as per your choice. The below example is just a simple explanation of how the add method works. from DSViz import GraphV test = GraphV () test . add ( 'run' , 'intr' ) test . add ( 'intr' , 'runbl' ) test . add ( 'runbl' , 'run' ) test . add ( 'run' , 'kernel' ) test . add ( 'kernel' , 'zombie' ) test . add ( 'kernel' , 'sleep' ) test . add ( 'kernel' , 'runmem' ) test . add ( 'sleep' , 'swap' ) test . add ( 'swap' , 'runswap' ) test . add ( 'runswap' , 'new' ) test . add ( 'runswap' , 'runmem' ) test . add ( 'new' , 'runmem' ) test . add ( 'sleep' , 'runmem' ) test . show","title":"Getting Started"},{"location":"guide/#getting-started","text":"DSViz is a simple and intuitive Python interface to multiple packages in order to help visualise different data structres while codng them. This package is developed mainly for students or developers who are in the process of learning data structures. How to use it ? Simple ! Step 1. Iterate over your Data Structure using the appropriate class Step 2. Call the .add() method on each node Step 3. Once you have added every node, use the .show property Step 4. Keep Coding ;) Here are a few examples...","title":"Getting Started"},{"location":"guide/#array-list","text":"Goal: Array List which stores even numbers from 2-100 from DSViz import ArrayListV test = ArrayListV () for i in range ( 1 , 51 ): test . addNode ( i * 2 ) test . show","title":"Array List"},{"location":"guide/#linked-list","text":"Goal: Circular Doubly Linked List which stores alphabets from a-z addNode(node) : adds nodes to the back of a linked list We suggest you start at the head of the linked list and iterate to the end and call the add method on each node. The below example gives an idea on how the add method works and how the data structure is visualised. LinkedListV object upon creation has default CLL = False and DLL = False. These can be toggled upon object creation to change the how the pointers in the visualisation. from DSViz import LinkedListV test = LinkedListV ( CLL = True , DLL = True ) for i in range ( 97 , 123 ): test . addNode ( chr ( i )) test . show","title":"Linked List"},{"location":"guide/#binary-tree","text":"Goal: Visualise a tree from DSViz import BinaryTreeV test = BinaryTreeV () test . add ( \"a\" , \"b\" , \"c\" ) test . add ( \"b\" , left = \"d\" ) test . add ( \"d\" , right = \"e\" ) test . show ()","title":"Binary Tree"},{"location":"guide/#graph","text":"Goal: Visualise an undirected graph add(node1, node2) : creates an edge between two nodes, if the node exists, it creates an edge between the two, if node does not exist, it creates the node and the edge. We suggest you to use the add method while iterating over your graph using BFS or DFS as per your choice. The below example is just a simple explanation of how the add method works. from DSViz import GraphV test = GraphV () test . add ( 'run' , 'intr' ) test . add ( 'intr' , 'runbl' ) test . add ( 'runbl' , 'run' ) test . add ( 'run' , 'kernel' ) test . add ( 'kernel' , 'zombie' ) test . add ( 'kernel' , 'sleep' ) test . add ( 'kernel' , 'runmem' ) test . add ( 'sleep' , 'swap' ) test . add ( 'swap' , 'runswap' ) test . add ( 'runswap' , 'new' ) test . add ( 'runswap' , 'runmem' ) test . add ( 'new' , 'runmem' ) test . add ( 'sleep' , 'runmem' ) test . show","title":"Graph"},{"location":"installation/","text":"Install This library requires the GraphViz to be installed. Mac We recommend using Homebrew to install GraphViz. Open terminal and run the following command (assuming you have Homebrew installed) brew install graphviz Windows Historically, installing Graphviz and PyGraphviz on Windows has been challenging. Fortunately, the Graphviz developers are working to fix this and their recent releases have much improved the situation. For this reason, PyGraphviz 1.7 only supports Graphviz 2.46.0 or higher on Windows. We recommend either manually installing the official binary release of Graphviz You may also need to install Visual C/C++, e.g. from here: https://visualstudio.microsoft.com/visual-cpp-build-tools/ Assuming you have Python and Visual C/C++ installed, we believe the following should work on Windows 10 (64 bit) using PowerShell. Manual download: Download and install 2.46.0 for Windows 10 (64-bit): stable_windows_10_cmake_Release_x64_graphviz-install-2.46.0-win64.exe Linux We recommend installing Graphviz using your Linux system's package manager. Below are examples for some popular distributions. Ubuntu and Debian sudo apt-get install graphviz graphviz-dev Fedora and Red Hat You may need to replace dnf with yum in the example below. sudo dnf install graphviz graphviz-devel Finally After installing GraphViz according to your OS, you can install our > package and the other dependencies using pip $ pip install DataStructureViz Credits to pygraphviz for specific instructions on downloading GraphViz.","title":"Installation"},{"location":"installation/#install","text":"This library requires the GraphViz to be installed.","title":"Install"},{"location":"installation/#mac","text":"We recommend using Homebrew to install GraphViz. Open terminal and run the following command (assuming you have Homebrew installed) brew install graphviz","title":"Mac"},{"location":"installation/#windows","text":"Historically, installing Graphviz and PyGraphviz on Windows has been challenging. Fortunately, the Graphviz developers are working to fix this and their recent releases have much improved the situation. For this reason, PyGraphviz 1.7 only supports Graphviz 2.46.0 or higher on Windows. We recommend either manually installing the official binary release of Graphviz You may also need to install Visual C/C++, e.g. from here: https://visualstudio.microsoft.com/visual-cpp-build-tools/ Assuming you have Python and Visual C/C++ installed, we believe the following should work on Windows 10 (64 bit) using PowerShell. Manual download: Download and install 2.46.0 for Windows 10 (64-bit): stable_windows_10_cmake_Release_x64_graphviz-install-2.46.0-win64.exe","title":"Windows"},{"location":"installation/#linux","text":"We recommend installing Graphviz using your Linux system's package manager. Below are examples for some popular distributions. Ubuntu and Debian sudo apt-get install graphviz graphviz-dev Fedora and Red Hat You may need to replace dnf with yum in the example below. sudo dnf install graphviz graphviz-devel","title":"Linux"},{"location":"installation/#finally","text":"After installing GraphViz according to your OS, you can install our > package and the other dependencies using pip $ pip install DataStructureViz Credits to pygraphviz for specific instructions on downloading GraphViz.","title":"Finally"},{"location":"license/","text":"License MIT License Copyright (c) 2021 Ish Mehta Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"MIT License Copyright (c) 2021 Ish Mehta Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"list/","text":"Class LinkedListV <object> = LinkedListV(DLL = False, CLL = False) : Creates an object of LinkedListV class Info We provide some flexibility while creating an object of this class. By default DLL and CLL are set to False. DLL stands for 'Doubly Linked List' CLL stands for 'Circular Linked List' While object creation, DLL and CLL can be set to True or False and accordingly the appropriate linked list will be rendered. <object>.addNode(..item..) will add node to the linked list beginning from head to tail. Note You can only add one item at a time. We suggest you iterate over the linked List and call the .addNode() method on every item. <object>.show : Once every node has been added, use this property to render the linked list.","title":"LinkedListV"},{"location":"list/#class-linkedlistv","text":"<object> = LinkedListV(DLL = False, CLL = False) : Creates an object of LinkedListV class Info We provide some flexibility while creating an object of this class. By default DLL and CLL are set to False. DLL stands for 'Doubly Linked List' CLL stands for 'Circular Linked List' While object creation, DLL and CLL can be set to True or False and accordingly the appropriate linked list will be rendered. <object>.addNode(..item..) will add node to the linked list beginning from head to tail. Note You can only add one item at a time. We suggest you iterate over the linked List and call the .addNode() method on every item. <object>.show : Once every node has been added, use this property to render the linked list.","title":"Class LinkedListV"},{"location":"section/","text":"","title":"Section"},{"location":"structure/","text":"Package Structure The idea of DSViz is to keep it simple and intuitive which is easy to use for even begginers. The package consists of 4 classes, each suited for a particular type of data structure. Thus, according to the type of structure to be visualised the apporpriate class is to be used. The following list are the class names: ArrayListV LinkedListV BinaryTreeV GraphV Note In the following documentation <object> describes the object of the appropriate class","title":"Package Structure"},{"location":"structure/#package-structure","text":"The idea of DSViz is to keep it simple and intuitive which is easy to use for even begginers. The package consists of 4 classes, each suited for a particular type of data structure. Thus, according to the type of structure to be visualised the apporpriate class is to be used. The following list are the class names: ArrayListV LinkedListV BinaryTreeV GraphV Note In the following documentation <object> describes the object of the appropriate class","title":"Package Structure"},{"location":"undirected_graph/","text":"Undirected Graph Example from DSViz import GraphV class graph : def __init__ ( self , adjlist , directed = False ): self . adjlist = adjlist self . directed = directed def visuliase ( self , start ): viz = GraphV ( Directed = self . directed ) edgeSet = set () VS = set () stack = [] curr = start stack . append ( curr ) while len ( stack ) != 0 : curr = stack . pop ( - 1 ) VS . add ( curr ) for adjacent in self . adjlist [ curr ]: found = False for element in edgeSet : if curr in element and adjacent in element : found = True if not found : viz . add ( curr , adjacent ) if adjacent not in VS : stack . append ( adjacent ) edgeSet . add (( adjacent , curr )) viz . show One can then utilise this 'visualise' method created. adjlist = { '0' : [ '1' , '4' ], '1' : [ '0' , '4' , '3' , '2' ], '2' : [ '1' , '3' ], '3' : [ '1' , '2' , '4' ], '4' : [ '0' , '1' , '3' ]} test = graph ( adjlist ) test . visuliase ( '4' ) A similar approach can be followed to visualise any form of graph regardless of its implementation specifics.","title":"Undirected Graph"},{"location":"undirected_graph/#undirected-graph-example","text":"from DSViz import GraphV class graph : def __init__ ( self , adjlist , directed = False ): self . adjlist = adjlist self . directed = directed def visuliase ( self , start ): viz = GraphV ( Directed = self . directed ) edgeSet = set () VS = set () stack = [] curr = start stack . append ( curr ) while len ( stack ) != 0 : curr = stack . pop ( - 1 ) VS . add ( curr ) for adjacent in self . adjlist [ curr ]: found = False for element in edgeSet : if curr in element and adjacent in element : found = True if not found : viz . add ( curr , adjacent ) if adjacent not in VS : stack . append ( adjacent ) edgeSet . add (( adjacent , curr )) viz . show One can then utilise this 'visualise' method created. adjlist = { '0' : [ '1' , '4' ], '1' : [ '0' , '4' , '3' , '2' ], '2' : [ '1' , '3' ], '3' : [ '1' , '2' , '4' ], '4' : [ '0' , '1' , '3' ]} test = graph ( adjlist ) test . visuliase ( '4' ) A similar approach can be followed to visualise any form of graph regardless of its implementation specifics.","title":"Undirected Graph Example"}]}